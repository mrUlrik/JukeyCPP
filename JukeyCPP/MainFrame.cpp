#include "MainFrame.h"

#include <optional>
#include <wx/event.h>
#include <wx/tokenzr.h>

// Event table connects the range of button IDs to the same handler method.
// EVT_COMMAND_RANGE maps any button with an ID between BUTTON_0 and BUTTON_NEG
// (inclusive) to the MainFrame::OnButtonClicked handler.
// This allows all button click events to be processed by a single method. Our 
// IDs enumerator starts with BUTTON_0 and ends with BUTTON_NEG.
wxBEGIN_EVENT_TABLE(MainFrame, wxFrame)
	EVT_COMMAND_RANGE(MainFrame::BUTTON_0, MainFrame::BUTTON_NEG, wxEVT_BUTTON, MainFrame::OnButtonClicked)
wxEND_EVENT_TABLE()

/**
 * MainFrame constructor
 *
 * Builds the calculator UI: a single-line right-aligned text control to show input
 * and results, plus a 6x4 grid of buttons representing digits, operators,
 * trig functions, and control keys (clear, backspace, equals).
 *
 * @param title The window title shown on the frame.
 */
MainFrame::MainFrame(const wxString& title)
	: wxFrame(nullptr, wxID_ANY, title)
{
	// Initially, no calculation has been performed.
	m_calculationComplete = false;

	// Use a vertical box sizer to stack the display control above the button grid.
	wxBoxSizer* mainSizer = new wxBoxSizer(wxVERTICAL);

	// Create the display text control. wxTE_RIGHT aligns text to the right, which
	// is typical for calculator displays.
	m_displayBox = new wxTextCtrl(this, wxID_ANY, "", wxDefaultPosition, wxDefaultSize, wxTE_RIGHT);
	mainSizer->Add(m_displayBox, 0, wxEXPAND | wxALL, 5);

	// Create a grid sizer (6 rows, 4 columns) with spacing of 5 pixels between cells.
	wxGridSizer* grid = new wxGridSizer(6, 4, 5, 5);

	// First row: Clear, Backspace, spacer, Modulus
	grid->Add(new wxButton(this, BUTTON_CLEAR, "C"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_BACK, "<"), 1, wxEXPAND);
	grid->AddStretchSpacer();
	grid->Add(new wxButton(this, BUTTON_MOD, "%"), 1, wxEXPAND);

	// Second row: trigonometric functions and divide
	grid->Add(new wxButton(this, BUTTON_SIN, "sin"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_COS, "cos"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_TAN, "tan"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_DIVIDE, "/"), 1, wxEXPAND);

	// Digit and operator rows
	grid->Add(new wxButton(this, BUTTON_7, "7"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_8, "8"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_9, "9"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_MULTIPLY, "x"), 1, wxEXPAND);

	grid->Add(new wxButton(this, BUTTON_4, "4"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_5, "5"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_6, "6"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_SUBTRACT, "-"), 1, wxEXPAND);

	grid->Add(new wxButton(this, BUTTON_1, "1"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_2, "2"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_3, "3"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_ADD, "+"), 1, wxEXPAND);

	// Bottom row: negate toggle, zero, decimal point, equals
	grid->Add(new wxButton(this, BUTTON_NEG, "-"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_0, "0"), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_DECIMAL, "."), 1, wxEXPAND);
	grid->Add(new wxButton(this, BUTTON_EQUALS, "="), 1, wxEXPAND);

	// Add grid to main sizer and set the sizer on the frame.
	mainSizer->Add(grid, 1, wxEXPAND | wxALL, 5);
	this->SetSizer(mainSizer);
}

/**
 * Event handler for all calculator buttons.
 *
 * This method receives button click events for all buttons mapped via the
 * EVT_COMMAND_RANGE macro. It inspects the button ID or label and updates the
 * display accordingly, performing calculations when "=" is pressed.
 *
 * @param evt The wxCommandEvent generated by a button click.
 */
void MainFrame::OnButtonClicked(wxCommandEvent& evt)
{
	// Get the integer ID of the clicked control.
	int id = evt.GetId();

	// The event's source is expected to be a wxButton; use dynamic_cast to safely
	// recover the button pointer. If it's not a button, do nothing.
	wxButton* btn = dynamic_cast<wxButton*>(evt.GetEventObject());
	if (!btn) return;

	// Read the button label (e.g., "1", "+", "sin") and the current display text.
	wxString label = btn->GetLabel();
	wxString currentText = m_displayBox->GetValue();

	// Handle the equals button: perform calculation based on the contents of the display.
	if (id == BUTTON_EQUALS)
	{
		double result = 0.0;
		bool isValidMath = false; // Tracks whether we successfully computed a value.

		// Handle simple unary trig functions: the display should start with "sin", "cos", or "tan"
		// followed immediately by a number (e.g., "sin30" or "cos1.5708").
		if (currentText.StartsWith("sin"))
		{
			// AfterFirst('n') returns substring after the first 'n' character,
			// effectively removing "sin" -> leaves the numeric argument.
			wxString numStr = currentText.AfterFirst('n');

			double num;
			// wxString::ToDouble returns true if conversion succeeded.
			if (numStr.ToDouble(&num))
			{
				result = std::sin(num);
				isValidMath = true;
			}
		}
		else if (currentText.StartsWith("cos"))
		{
			// Remove "cos" by taking substring after the first 's'.
			wxString numStr = currentText.AfterFirst('s');

			double num;
			if (numStr.ToDouble(&num))
			{
				result = std::cos(num);
				isValidMath = true;
			}
		}
		else if (currentText.StartsWith("tan"))
		{
			// Remove "tan" by taking substring after the first 'n'.
			wxString numStr = currentText.AfterFirst('n');
			double num;
			if (numStr.ToDouble(&num))
			{
				result = std::tan(num);
				isValidMath = true;
			}
		}
		else
		{
			// For binary operations, we tokenize the input using the operator characters
			// as delimiters. Delimiters: "%/x-+".
			// Example "12+34" -> tokens "12" and "34", last delimiter "+".
			wxStringTokenizer tokenizer(currentText, "%/x-+");

			// If tokenizer.HasMoreTokens() is true, there is at least one token (operand).
			if (tokenizer.HasMoreTokens())
			{
				double num1, num2;

				// Get the first token (the left operand).
				wxString firstToken = tokenizer.GetNextToken();

				if (firstToken.IsEmpty())
				{
					// If the first token is empty, it means the user input started with
					// an operator (e.g., "-5+3"). We can handle this by prepending a '0'
					// to the expression to make it "0-5+3".
					wxString delimiter = tokenizer.GetLastDelimiter();
					firstToken = delimiter + tokenizer.GetNextToken();
				}

				// Convert first token to double and ensure there is a second token.
				if (tokenizer.HasMoreTokens() && firstToken.ToDouble(&num1))
				{
					// Get the last delimiter seen by the tokenizer. This is the operator used.
					// Note: GetLastDelimiter returns a wxString containing the delimiter char.
					wxString op = tokenizer.GetLastDelimiter();

					// We're going to cheat here. If the second token is empty and the last delimiter
					// was a '-', it means the user is trying to enter a negative number.
					// For example, they entered: 5+-1. We catch '+' as the operator and '' as the
					// second token because there is nothing between '+' and '-'.
					wxString secondToken = tokenizer.GetNextToken();
					if (secondToken.IsEmpty())
					{
						// And since we're dealing with text here, the cheat is just to prepend a
						// '-' to the next token we get to treat it as a negative number.
						wxString delimiter = tokenizer.GetLastDelimiter();
						secondToken = delimiter + tokenizer.GetNextToken();
					}

					// Convert second token to double and perform the corresponding operation.
					if (!tokenizer.HasMoreTokens() && secondToken.ToDouble(&num2))
					{
						// Compare op to single-character operator strings and compute result.
						if (op == '%') result = std::fmod(num1, num2);
						else if (op == '/') result = num1 / num2;
						else if (op == 'x') result = num1 * num2;
						else if (op == '-') result = num1 - num2;
						else if (op == '+') result = num1 + num2;

						isValidMath = true;
					}
				}
			}
		}

		// If a calculation was completed successfully, format the result and set the display.
		// Format "%.6g" prints up to 6 significant digits and avoids trailing zeros.
		if (isValidMath) m_displayBox->SetValue(wxString::Format("%.6g", result));

		// If no valid math operation was parsed or conversion failed, notify the user.
		else m_displayBox->SetValue("Error: Unable to parse user input.");

		m_calculationComplete = true;
	}
	
	// Clear: clears the entire field
	else if (id == BUTTON_CLEAR)
	{
		currentText.clear();
		m_displayBox->Clear();
	}
	
	// Back: removes the last character from the display if not empty.
	else if (id == BUTTON_BACK)
	{
		if (!currentText.IsEmpty())
		{
			currentText.RemoveLast();
			m_displayBox->SetValue(currentText);
		}
	}
	
	// Default behavior: append the button label to the display. This handles digits,
	// decimal point, operators (those mapped as buttons), and trig labels when typed.
	else
	{

		// BEGIN: Totally optional UX improvement.
		// If a calculation was just completed and the user presses a digit or decimal point,
		// clear the display before appending new input.
		if (m_calculationComplete) {

			// Check if the button pressed is an operator. If button label is one of "+", "-", "x", "/", "%".
			bool isOperator = (label == "+" || label == "-" || label == "x" || label == "/" || label == "%");

			// If the screen says "Error", we must ALWAYS clear it.
			if (currentText.StartsWith("Error"))
			{
				currentText.clear();
				m_displayBox->Clear();
			}

			// If it's a valid number, we only clear if they typed a new NUMBER or TRIG function.
			// We do NOT clear if they typed an OPERATOR (because they want to do 10 + 5).
			else if (!isOperator)
			{
				currentText.clear();
				m_displayBox->Clear();
			}

			// We have handled the state, so reset it.
			m_calculationComplete = false;
		}

		// END: Totally optional UX improvement.

		currentText += label;
		m_displayBox->SetValue(currentText);
	}

	// Allow other handlers to process this event if needed. Built-in function to the
	// library and recommended to be called.
	evt.Skip();
}